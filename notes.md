## python formatter

make sure to have autopep8 extension installed

## Django App concept

An app in Django is a Python package that encapsulates related models, views, templates, and other supporting files necessary to implement a specific web application feature or functionality. Each app is designed to be modular, allowing developers to create, manage, and reuse discrete components of functionality across different projects.

```python
python3 manage.py startapp <name_for_the_package>
```

## Urls and Views

Urls are the routes for the application in general and views are functions (or classes) that execute some logic when certain url or route is reached, targeted or visited, then returning a response.

[URL dipatcher](https://docs.djangoproject.com/en/5.0/topics/http/urls/)
[Base views](https://docs.djangoproject.com/en/5.0/ref/class-based-views/base/)

### When creating a view

- Accept a request
- Return a response

#### View argument types

- HttpRequest: This is the most common type of argument for a Django view function. It represents the HTTP request made by the client and includes information such as headers, body, method (GET, POST, etc.), and user session data.

- URL Parameters: Views can receive URL parameters captured from the URL pattern using named groups or regular expressions. These parameters are typically used to pass dynamic data to the view, such as an item ID in a product detail page (/products/<int:item_id>/).

- GET Parameters: Views can access GET parameters sent in the URL query string. For example, in the URL /search/?q=query, the view can receive the q parameter with the value query.

- POST Data: Views handling POST requests can receive data submitted by the client in the request body. This data is often sent through HTML forms and can include fields like text inputs, checkboxes, and file uploads.

- Named Arguments (kwargs): Views can also receive named arguments (\*\*kwargs) in addition to the request object. This is useful for passing additional context or configuration to the view function.

#### Response types

- HttpResponse: Basic HTTP response that can include HTML content.
- JsonResponse: Response containing JSON data.
- HttpResponseRedirect: Redirects the client to a different URL.
- HttpResponseNotFound: Returns a 404 Not Found response.
- HttpResponseServerError: Returns a 500 Internal Server Error response.
- StreamingHttpResponse: Response for streaming large amounts of data.
- FileResponse: Response for serving files (e.g., PDF, images).

### When setting url dispatchers

- should be in a list of paths, generated by path() function each
- apps are not created with urls.py, make sure to create it
- include this app url dispatchers in the main url module

### Path converters

In Django, path converters are special components used in URL patterns to capture and convert parts of a URL into Python data types. They are used within URL patterns defined in Django's URL dispatcher to extract dynamic segments from URLs and pass them as arguments to view functions. Path converters are denoted by angled brackets < > in URL patterns and come in various types, each serving a specific purpose. Here are some common path converters in Django:

- int: Converts the matched string to an integer. For example, <int:pk> captures an integer and passes it as an argument to the view function.

- str: Captures any string without a slash. For example, <str:username> captures a username from the URL.

- slug: Similar to str but ensures the captured string is valid for a URL segment. It's often used for URLs containing human-readable text. For example, <slug:slug_text> captures a slug text from the URL.

- uuid: Captures a Universally Unique Identifier (UUID) from the URL. For example, <uuid:uuid_value> captures a UUID from the URL.

- path: Captures the remainder of the URL as a string, including slashes. It's useful for capturing multiple path segments. For example, <path:file_path> captures a file path from the URL.

- Custom converters: Django also allows developers to define custom path converters for handling specialized data types or custom conversion logic.

```python
from django.urls import path
from . import views

urlpatterns = [
    path('blog/<int:year>/', views.year_archive),
    path('blog/<int:year>/<str:month>/', views.month_archive),
    path('blog/<int:year>/<str:month>/<slug:slug>/', views.post_detail),
]

```

### Name arg and reverse

In the context of Django's URL routing system, "reverse" refers to the process of generating a URL based on a named URL pattern and its corresponding view function. This is particularly useful when you want to create URLs dynamically in your code or templates without hardcoding them.

## Templates folder

```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

```

The recommended structure for the templates folder in Django projects is to have subfolders named after each app within the project, and the templates specific to each app should be placed within their respective subfolders. This approach helps maintain a well-organized and structured codebase.

- 'BACKEND': 'django.template.backends.django.DjangoTemplates' specifies the Django template engine.
- 'DIRS': [] is an empty list by default, which means Django will not search for templates in any specific directories specified here.
- 'APP_DIRS': True indicates that Django should look for templates within the templates directories of each app in your project. This is the key setting that enables Django to automatically find templates based on the app structure.

When 'APP_DIRS': True, Django will search for templates in the following locations for each app:

/<app_name>/templates/ (inside each app's directory)
/<project_name>/<app_name>/templates/ (if the app is installed as part of a larger project, Django will also search in this location)
You can customize this behavior by adding directories to the 'DIRS' list if you want Django to search in additional directories for templates that are not specific to any app. However, the default and recommended approach is to rely on 'APP_DIRS': True for locating app-specific templates.
